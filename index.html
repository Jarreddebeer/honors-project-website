<html lang="en">
<head>
    <link rel="stylesheet" href="./css/bootstrap.min.css" />
    <link rel="stylesheet" href="./css/github-markdown.css" />
    <link rel="stylesheet" href="./css/style.css" />
    <link rel="stylesheet" href="./css/font-awesome.min.css">
    <link href="JuliusSansOne-Regular.ttf" rel="stylesheet" type="text/css">
</head>

<div class="app-wrapper">

    <header class="navbar navbar-default" id="top" role="banner">
      <div class="container">
        <div class="navbar-header">
          <a href="/" class="navbar-brand">GPUStar</a>
        </div>
        <nav>
          <ul class="nav navbar-nav navbar-right">
              <li><a href="#overview">Overview</a></li>
              <li><a href="#results">Results</a></li>
              <li><a href="#writeup">Writeup</a></li>
              <li><a href="#downloads">Downloads</a></li>
          </ul>
        </nav>
      </div>
    </header>

<div id="introduction">

        <div class="blocks">
            <div class="block-container">
                <div class="intro-text clearfix">
                    <div id="by">
                        <h1>Accelerating Automated Extraction of Radio Astronomical Sources from Observation Data with GPU Accelerators</h1>
                        <span class="students">by Yaseen Hamdulay and Jarred de Beer</span>
                        <span class="supervised">supervised by Assoc. Prof Michelle Kuttel and Dr Sarah Blyth</span>
                    </div>
                    <div id="objective">
                        <img src="./img/spiral-galaxy-icon.svg" class="spiral" />
                        <h1>GPUSTAR</h1>
                        <p>To accelerate the automated identification of galaxies in radio astronomical data from next generation MEERKAT and ASKAP surveys using graphical processors</p>
                    </div>
                </div>
            </div>
        </div>

        <svg class="starfield far a"></svg>
        <svg class="starfield far b"></svg>

        <svg class="starfield medium a"></svg>
        <svg class="starfield medium b"></svg>

        <svg class="starfield nearby a"></svg>
        <svg class="starfield nearby b"></svg>

        <svg class="lightspeed-starfield nearby a"></svg>
        <svg class="lightspeed-starfield nearby b"></svg>
</div>

<div id="main">

    <div class="row" id="overview">

        <div class="duchamp col-sm-5">
            <div id="report-target-duchamp" class="col-sm-12 report">
                <h1>DUCHAMP</h1>
                <p>Radio astronomy surveys observe portions of the sky using radio telescopes for 21cm emission lines of neutral hydrogen gas (HI) from distant galaxies \cite{holwerda2010trumpeting}. The HI emission line is the electromagnetic radiation spectral line which is generated by a change in the hydrogen atom's magnetic state. This radiation has a measurable wavelength of 21cm in a vacuum and falls within the microwave radio frequency range which is observable from the earths surface penetrating the earth's atmosphere, cloud and cosmic dust. The HI emissions occur with extremely small frequencies yet due to the sheer number of HI particles in galaxies they occur often enough to be observed. The resulting data from the telescopes is in the form of a 3 dimensional array and Astronomers are able to detect observations by manual inspection. This has been the traditional approach, and the detection process is known as source finding.</p>
            </div>
        </div>

        <div class="center-column col-sm-2">
            <img id="antenna" src="./img/satelite-icon.svg" />
            <img id="tower" src="./img/computer-tower-icon.svg" />
        </div>

        <div class="sofia col-sm-5">

            <div id="report-target-sofia" class="col-sm-12 report">
                <h1>SoFiA</h1>
                <p>Radio astronomy surveys observe portions of the sky using radio telescopes for 21cm emission lines of neutral hydrogen gas (HI) from distant galaxies \cite{holwerda2010trumpeting}. The HI emission line is the electromagnetic radiation spectral line which is generated by a change in the hydrogen atom's magnetic state. This radiation has a measurable wavelength of 21cm in a vacuum and falls within the microwave radio frequency range which is observable from the earths surface penetrating the earth's atmosphere, cloud and cosmic dust. The HI emissions occur with extremely small frequencies yet due to the sheer number of HI particles in galaxies they occur often enough to be observed. The resulting data from the telescopes is in the form of a 3 dimensional array and Astronomers are able to detect observations by manual inspection. This has been the traditional approach, and the detection process is known as source finding.</p>
            </div>
        </div>
    </div>

    <div class="row cuda-header" id="results">
        <div class="col-sm-5">
            <div class="speedup-graph">
                <img src="./img/duchamp-accelerated-results.jpg" />
            </div>
        </div>
        <div class="col-sm-2 center-column">
            <h3>Results</h3>
            <img src="./img/cpu-icon.svg" />
            <img src="./img/gpu-icon.svg" />
        </div>
        <div class="col-sm-5">
            <div class="speedup-graph">
                <img src="./img/sofia-accelerated-results.png" />
            </div>
        </div>
    </div>

</div> <!-- main -->

</div> <!-- app-wrapper -->
<div class="app-wrapper light">


    <div class="row" id="writeup">
        <div class="col-sm-6">

            <div class="speedup-graph">
                <p><i class="fa fa-quote-left"></i>Execution time of the Smooth-and-Clip and RMS methods decreased from 535 to 70 seconds, an acceleration of 8.6x<i class="fa fa-quote-right"></i></p>
            </div>

            <p>The traditional approach to source finding will become redundant with the advent of future radio astronomy surveys \cite{whiting2012source} such as MeerKAT (Meer Karoo Array Telescope) and ASKAP (Australian Square Kilometer Array Pathfinder). These are grids of radio telescopes which form an array, called an interferometer. The HI emissions occur at such large distances from earth that the frontier of a wave is effectively linear and each radio telescope within the array is able to detect the time at which the line is detected and the difference in time can be used to determine the velocity of the wave. The spectral frequency and other important observations for Astrophysical research and study can be obtained from this. The array based nature of interferometers is an alternative to deep, high resolution surveys which have previously only been capable by much larger, stand-alone dishes that are expensive, restricted in range because of their size, and cumbersome to manoeuvre. In contrast, with interferometers multiple smaller, robust and less expensive dishes can be used. The amount of data produced by these interferometers is orders of magnitude larger than traditional surveys and manual inspection will no longer be viable. Automating the source finding process has become a necessity and various software packages have been developed to achieve this. However, they are still too slow and research into accelerating them has revealed key 
            bottlenecks in their performance \cite{scottBadenhorst}. In this project we identify algorithms from two such bottlenecks and attempt to accelerate them with CUDA (Compute Unified Device Architecture), which is a parallel programming model that is integrated into the GPUs (Graphics Processing Unit) of a range of NVIDIA graphics cards.</p>

            <p>The GPU is a highly parallel, low-cost computational alternative to the CPU with a considerably lower energy footprint \cite{huang2009energy}. A GPU is comprised of streaming multiprocessors which each contain dedicated arithmetic units and a variety of memory hierarchies. They exploit data level parallelism by implementing SIMD (Single Instruction Multiple Data) and MIMD (Multiple Instruction Multiple Data) performed by blocks of threads. Threads are lightweight and designed to incur minimal time penalties for
            context switching, which helps maximise thread occupancy. Fluke et al. report that in particular cases GPU implementations perform ten to a hundred times faster than their single-threaded CPU counterparts. The most performant solutions, however, can be particularly difficult to achieve.</p>

            <p>The algorithms which have been identified as bottlenecks are the 2D-1D wavelet reconstruction and the S+C (Source and Clip) source finder. 2D-1D wavelet reconstruction is a smoothing process to remove noise from data, prior to source detection. This smoothing process is depended upon by intensity threshold source finding algorithms and may consume up to 70\% of the overall runtime \cite{scottBadenhorst}. The S+C source finding algorithm is an intensity threshold source finder which performs a smooth and clip operation to
            detect sources and is one of two source finders integrated into the SoFiA package. SoFiA is a source finding package which is designed to be flexible and used in various ranges of surveys at ASKAP \cite{serra2015sofia}. In addition to implementing S+C, SoFiA has also integrated the 2D-1D wavelet reconstruction algorithm into the filtering stage of its pipeline. The package is designed to be modular and can be extended by the community to further enhance its use as a general source finding
            package. SoFiA is released under the GPLv2 license and is available on Github. The 2D-1D wavelet reconstruction algorithm is also used in the filtering process of the DUCHAMP package. DUCHAMP is an intensity based source finder which has the highest reliability among a range of source finders \cite{whiting2012duchamp}. The DUCHAMP package is written in C and released under the GPLv3 license.</p>

            <p>We aim to make automated source finding  more viable for the future larger radio astronomy surveys. This is of particular benefit to the MeerKAT and ASKAP projects, as well as developers and Astronomers making use of these packages for source finding.</p>

        </div>
        <div class="col-sm-6">

            <div class="speedup-graph">
                <p><i class="fa fa-quote-left"></i>Execution time of the Smooth-and-Clip and RMS methods decreased from 535 to 70 seconds, an acceleration of 8.6x<i class="fa fa-quote-right"></i></p>
            </div>

            <p>The traditional approach to source finding will become redundant with the advent of future radio astronomy surveys \cite{whiting2012source} such as MeerKAT (Meer Karoo Array Telescope) and ASKAP (Australian Square Kilometer Array Pathfinder). These are grids of radio telescopes which form an array, called an interferometer. The HI emissions occur at such large distances from earth that the frontier of a wave is effectively linear and each radio telescope within the array is able to detect the time at which the line is detected and the difference in time can be used to determine the velocity of the wave. The spectral frequency and other important observations for Astrophysical research and study can be obtained from this. The array based nature of interferometers is an alternative to deep, high resolution surveys which have previously only been capable by much larger, stand-alone dishes that are expensive, restricted in range because of their size, and cumbersome to manoeuvre. In contrast, with interferometers multiple smaller, robust and less expensive dishes can be used. The amount of data produced by these interferometers is orders of magnitude larger than traditional surveys and manual inspection will no longer be viable. Automating the source finding process has become a necessity and various software packages have been developed to achieve this. However, they are still too slow and research into accelerating them has revealed key 
            bottlenecks in their performance \cite{scottBadenhorst}. In this project we identify algorithms from two such bottlenecks and attempt to accelerate them with CUDA (Compute Unified Device Architecture), which is a parallel programming model that is integrated into the GPUs (Graphics Processing Unit) of a range of NVIDIA graphics cards.</p>

            <p>The GPU is a highly parallel, low-cost computational alternative to the CPU with a considerably lower energy footprint \cite{huang2009energy}. A GPU is comprised of streaming multiprocessors which each contain dedicated arithmetic units and a variety of memory hierarchies. They exploit data level parallelism by implementing SIMD (Single Instruction Multiple Data) and MIMD (Multiple Instruction Multiple Data) performed by blocks of threads. Threads are lightweight and designed to incur minimal time penalties for
            context switching, which helps maximise thread occupancy. Fluke et al. report that in particular cases GPU implementations perform ten to a hundred times faster than their single-threaded CPU counterparts. The most performant solutions, however, can be particularly difficult to achieve.</p>

            <p>The algorithms which have been identified as bottlenecks are the 2D-1D wavelet reconstruction and the S+C (Source and Clip) source finder. 2D-1D wavelet reconstruction is a smoothing process to remove noise from data, prior to source detection. This smoothing process is depended upon by intensity threshold source finding algorithms and may consume up to 70\% of the overall runtime \cite{scottBadenhorst}. The S+C source finding algorithm is an intensity threshold source finder which performs a smooth and clip operation to
            detect sources and is one of two source finders integrated into the SoFiA package. SoFiA is a source finding package which is designed to be flexible and used in various ranges of surveys at ASKAP \cite{serra2015sofia}. In addition to implementing S+C, SoFiA has also integrated the 2D-1D wavelet reconstruction algorithm into the filtering stage of its pipeline. The package is designed to be modular and can be extended by the community to further enhance its use as a general source finding
            package. SoFiA is released under the GPLv2 license and is available on Github. The 2D-1D wavelet reconstruction algorithm is also used in the filtering process of the DUCHAMP package. DUCHAMP is an intensity based source finder which has the highest reliability among a range of source finders \cite{whiting2012duchamp}. The DUCHAMP package is written in C and released under the GPLv3 license.</p>

            <p>We aim to make automated source finding  more viable for the future larger radio astronomy surveys. This is of particular benefit to the MeerKAT and ASKAP projects, as well as developers and Astronomers making use of these packages for source finding.</p>

        </div>
    </div>

    <div class="row" id="downloads">
        <div class="col-sm-12">
            <h3>Downloads</h3>
            <table class="table">
                  <thead>
                    <tr>
                      <th>#</th>
                      <th>Title</th>
                      <th>Author</th>
                      <th>Twitter</th>
                      <th>Github</th>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <th scope="row">1</th>
                      <td><a target="_blank" href="./downloads/paper-gpustar-duchamp.pdf">DUCHAMP paper</a></td>
                      <td>Yaseen Hamdulay</td>
                      <td><a target="_blank" href="https://twitter.com/mrhamdulay"><i class="fa fa-twitter"></i></a></td>
                      <td><a target="_blank" href="https://github.com/MrHamdulay"><i class="fa fa-github"></i></a></td>
                    </tr>
                    <tr>
                      <th scope="row">2</th>
                      <td><a target="_blank" href="./downloads/paper-gpustar-sofia.pdf">SoFiA paper</a></td>
                      <td>Jarred de Beer</td>
                      <td><a target="_blank" href="https://twitter.com/jarrhead"><i class="fa fa-twitter"></i></a></td>
                      <td><a target="_blank" href="https://github.com/jarreddebeer"><i class="fa fa-github"></i></a></td>
                    </tr>
                  </tbody>
            </table>

        </div>
    </div>

</div>



<div id="footer">
    <div class="row">
        <div class="col-sm-4">
        </div>
        <div class="col-sm-4">
            <p>Department of Computer Science<br />
            University of Cape Town<br />
            Private Bag X3. Rondebosch 7701<br />
            tel: 021 650 2663
            </p>
        </div>
        <div class="col-sm-4">
        </div>
    </div>
</div>



<script src="./js/jquery.min.js"></script>
<script src="./js/d3.js"></script>
<script src="./js/markdown.min.js"></script>
<script>

/* MARKDOWN */

var src_sofia = document.getElementById('report-source-sofia');
var tgt_sofia = document.getElementById('report-target-sofia');
// tgt_sofia.innerHTML = markdown.toHTML(src_sofia.textContent);

var src_duchamp = document.getElementById('report-source-duchamp');
var tgt_duchamp = document.getElementById('report-target-duchamp');
// tgt_duchamp.innerHTML = markdown.toHTML(src_duchamp.textContent);


/* GRAPHS */

/*
render_speedups(".sofia .speedup-graph");

function render_speedups(selector) {

        // Set the dimensions of the canvas / graph
    var margin = {top: 30, right: 20, bottom: 30, left: 50},
        width = 650 - margin.left - margin.right,
        height = 400 - margin.top - margin.bottom;

    // Set the ranges
    var x = d3.scale.linear().range([0, width]);
    var y = d3.scale.linear().range([height, 0]);

    // Define the axes
    var xAxis = d3.svg.axis().scale(x)
        .orient("bottom").ticks(5);

    var yAxis = d3.svg.axis().scale(y)
        .orient("left").ticks(5);

    // Define the line
    var valueline = d3.svg.line()
        .x(function(d) { return x(d.size); })
        .y(function(d) { return y(d.duration); });

    // Adds the svg canvas
    var svg = d3.select(selector)
        .append("svg")
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom)
        .append("g")
            .attr("transform",
                  "translate(" + margin.left + "," + margin.top + ")");

    // Get the data
    data_original = [
        {size:327,duration:72},
        {size:720,duration:163},
        {size:2300,duration:535},
    ];

    data_accelerated = [
        {size:327,duration:20},
        {size:720,duration:31},
        {size:2300,duration:70},
    ];


        // Scale the range of the data
        x.domain([200, 2400]);
        y.domain([0, 600]);

        // Add the valueline path.
        svg.append("path")
            .attr("class", "line")
            .attr("d", valueline(data_original))
            .attr("stroke", "red");

        // Add the valueline path.
        svg.append("path")
            .attr("class", "line")
            .attr("d", valueline(data_accelerated))
            .attr("stroke", "green");

        // Add the markers
        svg.selectAll('circle.mark.orig').data(data_original).enter().append('svg:circle')
            .attr('class', 'mark')
            .attr('cx', function(d){return x(d.size);})
            .attr('cy', function(d){return y(d.duration);})
            .attr('fill', 'red')
            .attr('r', 3.5);

        svg.selectAll('circle.mark.accel').data(data_accelerated).enter().append('svg:circle')
            .attr('class', 'mark')
            .attr('cx', function(d){return x(d.size);})
            .attr('cy', function(d){return y(d.duration);})
            .attr('fill', 'green')
            .attr('r', 3.5);

        // Add the X Axis
        svg.append("g")
            .attr("class", "x axis")
            .attr("transform", "translate(0," + height + ")")
            .call(xAxis);

        // Add the Y Axis
        svg.append("g")
            .attr("class", "y axis")
            .call(yAxis);

    //});

}
*/



/* STAR FIELD GENERATION */

// generate star fields
/*
generate_star_field(400, 1, 'far');
generate_star_field(160, 2, 'medium');
generate_star_field(30, 4, 'nearby');
generate_lightspeed_field(8);
*/

function generate_star_field(population, radius, container) {

        ['a', 'b'].forEach(function(k) {

            var starfield = $('.starfield.' + container + '.' + k);
            var height = $('#introduction').outerHeight() + 60;
            var width = $('#introduction').width();
            starfield.css('height', height);
            starfield.css('width', width);
            for (var i = 0; i < population; i++) {
                var cx = parseInt(Math.random() * width);
                var cy = parseInt(Math.random() * height);
                var star = $(document.createElementNS('http://www.w3.org/2000/svg', 'circle')).attr({
                    r: radius,
                    cx: cx,
                    cy: cy,
                    fill: '#fff'
                });
                starfield.append(star);
            }

        });
}

function generate_lightspeed_field(population) {


    ['a', 'b'].forEach(function(k) {

        var starfield = $('.lightspeed-starfield.' + k);
        var height = $('#introduction').outerHeight() + 60;
        var width = $('#introduction').width();
        starfield.css('height', height);
        starfield.css('width', width);

        var rectangles = starfield.children();
        var population_diff = population - rectangles.length;

        if (population_diff < 0) {

            var to_remove = rectangles.slice(0, -population_diff);
            $(to_remove).remove();

        } else {

            for (var i = 0; i < population_diff; i++) {
                var x = parseInt(Math.random() * width);
                var y = parseInt(Math.random() * height);
                var w = parseInt(Math.random() * 20 + 60);
                var h = parseInt(Math.random() * 2 + 1);
                var streak = $(document.createElementNS('http://www.w3.org/2000/svg', 'rect')).attr({
                    width: w,
                    height: h,
                    x: x,
                    y: y,
                    fill: '#fff'
                });
                starfield.append(streak);
            }

        }

    });
}



</script>

</body>

</html>
